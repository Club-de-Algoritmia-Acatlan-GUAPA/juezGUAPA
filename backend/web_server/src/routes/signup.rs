use anyhow::{anyhow, Context, Result};
use axum::{
    extract::{Form, State},
    http::StatusCode,
    response::{IntoResponse, Response},
};
use rand::{distributions::Alphanumeric, thread_rng, Rng};
use uuid::Uuid;

use secrecy::{ExposeSecret, Secret};
use serde::Deserialize;
use sqlx::{Postgres, Transaction};

use crate::{
    authentication::password::compute_password_hash,
    domain::{email::Email, new_subscriber::NewSubscriber, user::UserName},
    email_client::EmailClient,
    startup::AppState,
    telemetry::spawn_blocking_with_tracing,
};

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FormData {
    name: String,
    email: String,
    password: String,
    password_confirmation: String,
}

pub struct SignUpError(anyhow::Error);

impl<E> From<E> for SignUpError
where
    E: Into<anyhow::Error>,
{
    fn from(err: E) -> Self {
        Self(err.into())
    }
}

impl IntoResponse for SignUpError {
    fn into_response(self) -> Response {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Something went wrong: {}", self.0),
        )
            .into_response()
    }
}

#[axum_macros::debug_handler]
pub async fn signup_post(
    State(state): State<AppState>,
    Form(form): Form<FormData>,
) -> Result<String, SignUpError> {
    println!("{:?}", form);

    let email = form.email.parse::<Email>()?;
    let username = form.name.parse::<UserName>()?;

    if form.password != form.password_confirmation {
        return Err(anyhow!("Passwords don't match").into());
    }

    let password_hash =
        spawn_blocking_with_tracing(move || compute_password_hash(Secret::new(form.password)))
            .await?
            .context("Unable to hash password")?;

    let new_subscriber = NewSubscriber {
        email,
        password_hash,
        username,
    };
    let mut transaction = state
        .pool
        .begin()
        .await
        .context("Failed to acquire a Postgres connection from the pool")?;

    let user_id = insert_new_subscriber(&new_subscriber, &mut transaction)
        .await
        .context("Failed to register new user")?;
    let confirmation_token = generate_confirmation_token();

    store_confirmation_token(&confirmation_token, user_id, &mut transaction)
        .await
        .context("Failed inserting token to db")?;

    transaction
        .commit()
        .await
        .context("Unable to realize registration")?;

    send_confirmation_email(
        &state.email_client,
        new_subscriber,
        &state.base_url,
        &confirmation_token,
    )
    .await
    .context("Failed to send a confirmation email.")?;

    Ok("Succesful registration".to_string())
}

#[tracing::instrument(name = "Insert new subscriber", skip(new_subscriber, transaction))]
pub async fn insert_new_subscriber(
    new_subscriber: &NewSubscriber,
    transaction: &mut Transaction<'_, Postgres>,
) -> Result<Uuid, sqlx::Error> {
    // user_id is auto generated by the database on insertion
    let user_id: Uuid = sqlx::query!(
        r#"
         INSERT INTO users ( email, password_hash, username )
         VALUES ( $1, $2, $3 )
         RETURNING user_id
         "#,
        new_subscriber.email.as_ref(),
        new_subscriber.password_hash.expose_secret(),
        new_subscriber.username.as_ref(),
    )
    .fetch_one(transaction)
    .await
    .map(|row| row.user_id)?;

    Ok(user_id)
}

#[tracing::instrument(name = "Store confirmation token", skip(token, transaction))]
pub async fn store_confirmation_token(
    token: &String,
    user_id: Uuid,
    transaction: &mut Transaction<'_, Postgres>,
) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
         INSERT INTO confirmation_tokens ( user_id, confirmation_token )
         VALUES ( $1, $2 )
         "#,
        user_id,
        token
    )
    .execute(transaction)
    .await?;

    Ok(())
}

#[tracing::instrument(
    name = "Send a confirmation email to a new subscriber",
    skip(email_client, new_subscriber, base_url, subscription_token)
)]
pub async fn send_confirmation_email(
    email_client: &EmailClient,
    new_subscriber: NewSubscriber,
    base_url: &str,
    subscription_token: &str,
) -> Result<()> {
    let confirmation_link = format!(
        "{}/confirm?confirmation_token={}",
        base_url, subscription_token
    );
    let plain_body = format!(
        "Bienvenido al Juez Guapa, estamos muy emocionados de que te unieras :D!.\n Por favor ingresa al siguiente {} Para confirmar tu subscripción.",
        confirmation_link
    );
    let html_body = format!(
        "<h1>Bienvenido al Juez Guapa, estamos muy emocionados de que te unieras!</h1><br /> <h2>Por favor ingresa al siguiente <a href=\"{}\">link</a> para confirmar tu subscripción.</h2>",
        confirmation_link
    );
    email_client
        .send_email(
            &new_subscriber.email,
            "Bienvenido++",
            &html_body,
            &plain_body,
        )
        .await
}

fn generate_confirmation_token() -> String {
    let mut rng = thread_rng();
    std::iter::repeat_with(|| rng.sample(Alphanumeric))
        .map(char::from)
        .take(25)
        .collect()
}
